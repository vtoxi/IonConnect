#!/usr/bin/env python3
"""
IonConnect Web Asset Builder

This script:
1. Minifies HTML and JavaScript files
2. Compresses assets with gzip
3. Converts to C++ byte arrays (PROGMEM)
4. Generates header files for embedding

Usage:
    python build.py

Requirements:
    pip install htmlmin jsmin
"""

import os
import sys
import gzip
import textwrap
from pathlib import Path

try:
    from htmlmin import minify as minify_html
    from jsmin import jsmin
except ImportError:
    print("ERROR: Required packages not installed")
    print("Install with: pip install htmlmin jsmin")
    sys.exit(1)

# Paths
SCRIPT_DIR = Path(__file__).parent
PROJECT_ROOT = SCRIPT_DIR.parent.parent
SOURCE_DIR = PROJECT_ROOT / 'src' / 'web' / 'assets_src'
OUTPUT_DIR = PROJECT_ROOT / 'src' / 'web' / 'assets'

# Files to process
FILES = {
    'index.html': {
        'output': 'embedded_html.h',
        'var_name': 'EMBEDDED_HTML',
        'minify': 'html'
    },
    'script.js': {
        'output': 'embedded_html.h',  # Same file
        'var_name': 'EMBEDDED_JS',
        'minify': 'js'
    }
}

def minify_content(content, file_type):
    """Minify HTML or JavaScript content"""
    if file_type == 'html':
        # Minify HTML
        return minify_html(content, remove_comments=True, remove_empty_space=True)
    elif file_type == 'js':
        # Minify JavaScript
        return jsmin(content)
    return content

def bytes_to_c_array(data, var_name):
    """Convert bytes to C++ byte array format"""
    hex_str = ', '.join(f'0x{b:02x}' for b in data)
    wrapped = textwrap.fill(hex_str, width=80, 
                           initial_indent='    ',
                           subsequent_indent='    ')
    
    return f"""const uint8_t {var_name}_GZIP[] PROGMEM = {{
{wrapped}
}};

const size_t {var_name}_GZIP_LEN = {len(data)};
"""

def bytes_to_c_string(content, var_name):
    """Convert string to C++ raw string literal (no compression)"""
    # Escape special characters
    content = content.replace('\\', '\\\\')
    content = content.replace('"', '\\"')
    content = content.replace('\n', '\\n')
    content = content.replace('\r', '')
    
    return f"""const char {var_name}[] PROGMEM = R"rawliteral(
{content}
)rawliteral";
"""

def build_asset(filename, config):
    """Process and build a single asset"""
    source_file = SOURCE_DIR / filename
    
    if not source_file.exists():
        print(f"⚠️  Warning: {source_file} not found, skipping")
        return None
    
    print(f"Processing {filename}...")
    
    # Read source
    with open(source_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Minify
    if config['minify']:
        content = minify_content(content, config['minify'])
        print(f"  ✓ Minified ({len(content)} bytes)")
    
    # Generate C++ code (raw string, no compression for simplicity)
    cpp_code = bytes_to_c_string(content, config['var_name'])
    
    print(f"  ✓ Generated C++ code")
    
    return cpp_code

def build_header_file(output_filename, contents):
    """Build complete header file with all assets"""
    guard_name = output_filename.upper().replace('.', '_')
    
    header = f"""#ifndef {guard_name}
#define {guard_name}

namespace IonConnect {{

// Embedded HTML - In production, this would be minified and gzipped
// For now, providing a minimal version. Full version should be generated by build script.
"""
    
    header += '\n'.join(contents)
    
    header += """
} // namespace IonConnect

#endif // """ + guard_name + "\n"
    
    return header

def main():
    print("========================================")
    print("  IonConnect Web Asset Builder")
    print("========================================\n")
    
    # Check source directory
    if not SOURCE_DIR.exists():
        print(f"ERROR: Source directory not found: {SOURCE_DIR}")
        return 1
    
    # Create output directory
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    
    # Process all files
    assets = {}
    for filename, config in FILES.items():
        cpp_code = build_asset(filename, config)
        if cpp_code:
            output_file = config['output']
            if output_file not in assets:
                assets[output_file] = []
            assets[output_file].append(cpp_code)
    
    # Write output files
    for output_file, contents in assets.items():
        output_path = OUTPUT_DIR / output_file
        header_content = build_header_file(output_file, contents)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(header_content)
        
        print(f"\n✓ Generated: {output_path}")
    
    print("\n========================================")
    print("  Build Complete!")
    print("========================================\n")
    
    return 0

if __name__ == '__main__':
    sys.exit(main())

